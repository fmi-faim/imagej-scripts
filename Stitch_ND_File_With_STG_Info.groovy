// @File ndFile
// @File stgFile
// @boolean overrideCalibration
// @double pixelSizeXY
// @double pixelSizeZ
// @String(choices={"2D", "3D"}) dimensionality
// @FormatService fs
// @LogService log

import groovy.time.TimeCategory		// time profiling
import loci.formats.ImageReader		// parsing ND calibration
import loci.formats.MetadataTools	// parsing ND calibration
import com.opencsv.CSVParser		// ND and STG file parsing

TILE_CONFIG_HEADER = /# Tile Configuration generated by Groovy script
dim = 3
multiseries = true

# Image coordinates
/

def main() {
	// timer { bioformatsParse() }
	// timer { scifioParse() }

	/* Parse nd file */
	(tileMap, channelMap, dimensions, settings) = parseND(ndFile)

	log.debug(tileMap)
	log.debug(channelMap)
	log.debug(dimensions)
	log.debug(settings)

	def fileInfo = [:]
	fileInfo.basename = ndFile.name.take(ndFile.name.lastIndexOf('.'))

	// TODO for each position: generate multiSeries name

	// for each position and channel: generate single file name
	posToFileMap = [:]
	channelMap.each { cIndex, chEntry  ->
		fileInfo.wave = (settings.DoWave && settings.WaveInFileName) ? "_w$cIndex${chEntry.name}" : ""
		posToFileMap[cIndex] = [:]
		tileMap.each { stagePos, posName ->
			fileInfo.stage = "_s$stagePos"
			fileInfo.ext = (chEntry.stack && settings.Version == 1) ? ".stk" : ".tif"
			//println createFileString(fileInfo)
			//println posName
			posToFileMap[cIndex][posName] = createFileString(fileInfo)
		}
	}

	log.info(posToFileMap) // channel => [ pos => file ]

	//   if !overrideCalibration:
	//     use BF or SCIFIO to get calibration data (and dimensionality)
	//   create map: Position label -> Series number, Single file

	// only if mode=positions
	// parse stg file
	//   create map: Position label -> coordinates / pixelSizeXY
	coordMap = parseSTG(stgFile, pixelSizeXY, pixelSizeXY)

	log.info(coordMap) // pos => x, y

	// required: map: dataset source => x,y,(z) coordinates


	// write TileConfig files
	//  - multiSeries: use ndFile and positions
	// writeMultiSeriesConfig(basename, tileMap, coordMap)
	//  - manual: use single files, respect channel if necessary
	channelMap.each { cIndex, chEntry ->
		writeTileConfig(ndFile, chEntry.name, posToFileMap[cIndex], coordMap, settings.DoZSeries ? 3 : 2)
	}

	// writeSingleChannelConfig(basename, posToFileMap, coordMap)
}

timer = { closure ->
	log.info("Timer started")
	timeStart = new Date()
    closure.call()
	timeStop = new Date()
	duration = TimeCategory.minus(timeStop, timeStart)
	log.info("Time spent: " + duration)
}

// TODO get list of series 1) manually 2) using BF 3) using SCIFIO
def bioformatsParse() {
	ndPath = ndFile.getPath()
	reader = new ImageReader()
	omeMeta = MetadataTools.createOMEXMLMetadata()
	reader.setMetadataStore(omeMeta)
	reader.setId(ndPath)
	def dims = [] // TODO also get total size Z, return map
	dims << omeMeta.getPixelsPhysicalSizeX(0)
	dims << omeMeta.getPixelsPhysicalSizeY(0)
	reader.close()
	log.info(dims)
}

def scifioParse() {
	ndPath = ndFile.getPath()
	println ("Parsing with SCIFIO: " + ndPath)
	def format = fs.getFormat(ndPath)
	def metadata = format.createParser().parse(ndPath).get(0)
	def dims = [] // TODO also get total size Z, return map
	metadata.getAxes().each { axis ->
		dims << axis.averageScale(0,1)
	}
	log.info(dims)
}

/**
 * Create file name string from metadata info
 */
def createFileString(info) {
	info.basename + (info.wave ?: "") + info.stage + (info.time ?: "") + info.ext
}

/**
 * Parse a Metamorph .nd file using CSVParser
 * 
 * @param file - ND file object
 * 
 * @return positions
 * @return channels
 * @return dimensions
 * @return settings
 */
def parseND(file) {
	def positions = [:]
	def channels = [:]
	def dimensions = [:]
	def settings = [:]
	parser = new CSVParser(',' as char, '"' as char)
	file.eachLine {
		cols = parser.parseLine(it)
		switch (cols[0]) {
			// Stage positions
			case { it.startsWith("Stage")}:
				positions.put(cols[0][5..-1] as int, cols[1])
				break

			// Channel names and z config
			case { it.startsWith("WaveName")}:
				//channels.put(cols[0][8..-1] as int, cols[1])
				channels[cols[0][8..-1]] = channels[cols[0][8..-1]] ?: [:]
				channels[cols[0][8..-1]].put('name', cols[1])
				break
			case { it.startsWith("WaveDoZ")}:
				//channels.put(cols[0][8..-1] as int, cols[1])
				channels[cols[0][7..-1]] = channels[cols[0][7..-1]] ?: [:]
				channels[cols[0][7..-1]].put('stack', cols[1].trim() == "TRUE")
				break

			// Settings
			case "NDInfoFile":
				settings.put("Version", cols[1][8..-1].toDouble().round())
				break
			case "DoTimelapse":
				settings.put("DoTimelapse", cols[1].trim() == "TRUE")
				break
			case "DoStage":
				settings.put("DoStage", cols[1].trim() == "TRUE")
				break
			case "DoWave":
				settings.put("DoWave", cols[1].trim() == "TRUE")
				break
			case "DoZSeries":
				settings.put("DoZSeries", cols[1].trim() == "TRUE")
				break
			case "WaveInFileName":
				settings.put("WaveInFileName", cols[1].trim() == "TRUE")
				break

			// Dimensions
			case "NWavelengths":
				dimensions.put("c", cols[1] as int)
				break
			case "NZSteps":
				dimensions.put("z", cols[1] as int)
				break
			case "NTimePoints":
				dimensions.put("t", cols[1] as int)
				break
			case "NStagePositions":
				dimensions.put("s", cols[1] as int)
				break
			default:
				break
		}
	}
	[positions, channels, dimensions, settings]
}

/**
 * Parse a Metamorph .stg file using CSVParser
 * 
 * @param file - STG file object
 * @param scaleX - pixel width calibration
 * @param scaleY - pixel hieght calibration
 * 
 * @return coordinates
 */
def parseSTG(file, scaleX, scaleY) {
	def coords = [:]
	parser = new CSVParser(',' as char, '"' as char)
	file.eachLine(-3) { line, n -> // TODO do we need the actual value of n here?
		if (n > 0) {
			cols = parser.parseLine(line)
			xy = [x: (cols[1] as double) / scaleX, y: (cols[2] as double) / scaleY]
			coords[cols[0]] = xy
		}
	}
	coords
}

/**
 * Write TileConfiguration_basename_channel.txt
 */
def writeTileConfig(ndFile, channelName, fileMap, coordMap, dim) {
	tcFile = new File(ndFile.getParent(), ndFile.name.take(ndFile.name.lastIndexOf('.')) + "_${channelName}_TileConfiguration.txt")
	tcFile.withWriter { writer ->
		//writer.write(TILE_CONFIG_HEADER) // TODO write: dim={2|3}, (multiseries=false)
		writer.write("# Tile Configuration generated by Stitch_ND_File_With_STG_Info.groovy\n")
		writer.write("dim = $dim\n")
		writer.write("# Image Coordinates\n")
		thirdDim = (dim == 3) ? ", 0" : ""
		fileMap.each { key, name ->
			def line = "$name; ; (${coordMap[key].x} , ${coordMap[key].y}$thirdDim)"
			//def line = nd.getName() + "; " + (it[0]-1) + "; " + "( " + (it[1]/sizeX) + ", " + (it[2]/sizeY) + ", 0)"
			writer.write(line)
			writer.newLine()
		}
	}
	log.info("Finished writing " + tcFile.getName())
}

main()
